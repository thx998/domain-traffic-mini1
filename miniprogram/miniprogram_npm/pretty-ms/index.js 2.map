{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nconst parseMilliseconds = require('parse-ms');\n\nconst pluralize = (word, count) => count === 1 ? word : `${word}s`;\n\nconst SECOND_ROUNDING_EPSILON = 0.0000001;\n\nmodule.exports = (milliseconds, options = {}) => {\n\tif (!Number.isFinite(milliseconds)) {\n\t\tthrow new TypeError('Expected a finite number');\n\t}\n\n\tif (options.colonNotation) {\n\t\toptions.compact = false;\n\t\toptions.formatSubMilliseconds = false;\n\t\toptions.separateMilliseconds = false;\n\t\toptions.verbose = false;\n\t}\n\n\tif (options.compact) {\n\t\toptions.secondsDecimalDigits = 0;\n\t\toptions.millisecondsDecimalDigits = 0;\n\t}\n\n\tconst result = [];\n\n\tconst floorDecimals = (value, decimalDigits) => {\n\t\tconst flooredInterimValue = Math.floor((value * (10 ** decimalDigits)) + SECOND_ROUNDING_EPSILON);\n\t\tconst flooredValue = Math.round(flooredInterimValue) / (10 ** decimalDigits);\n\t\treturn flooredValue.toFixed(decimalDigits);\n\t};\n\n\tconst add = (value, long, short, valueString) => {\n\t\tif ((result.length === 0 || !options.colonNotation) && value === 0 && !(options.colonNotation && short === 'm')) {\n\t\t\treturn;\n\t\t}\n\n\t\tvalueString = (valueString || value || '0').toString();\n\t\tlet prefix;\n\t\tlet suffix;\n\t\tif (options.colonNotation) {\n\t\t\tprefix = result.length > 0 ? ':' : '';\n\t\t\tsuffix = '';\n\t\t\tconst wholeDigits = valueString.includes('.') ? valueString.split('.')[0].length : valueString.length;\n\t\t\tconst minLength = result.length > 0 ? 2 : 1;\n\t\t\tvalueString = '0'.repeat(Math.max(0, minLength - wholeDigits)) + valueString;\n\t\t} else {\n\t\t\tprefix = '';\n\t\t\tsuffix = options.verbose ? ' ' + pluralize(long, value) : short;\n\t\t}\n\n\t\tresult.push(prefix + valueString + suffix);\n\t};\n\n\tconst parsed = parseMilliseconds(milliseconds);\n\n\tadd(Math.trunc(parsed.days / 365), 'year', 'y');\n\tadd(parsed.days % 365, 'day', 'd');\n\tadd(parsed.hours, 'hour', 'h');\n\tadd(parsed.minutes, 'minute', 'm');\n\n\tif (\n\t\toptions.separateMilliseconds ||\n\t\toptions.formatSubMilliseconds ||\n\t\t(!options.colonNotation && milliseconds < 1000)\n\t) {\n\t\tadd(parsed.seconds, 'second', 's');\n\t\tif (options.formatSubMilliseconds) {\n\t\t\tadd(parsed.milliseconds, 'millisecond', 'ms');\n\t\t\tadd(parsed.microseconds, 'microsecond', 'Âµs');\n\t\t\tadd(parsed.nanoseconds, 'nanosecond', 'ns');\n\t\t} else {\n\t\t\tconst millisecondsAndBelow =\n\t\t\t\tparsed.milliseconds +\n\t\t\t\t(parsed.microseconds / 1000) +\n\t\t\t\t(parsed.nanoseconds / 1e6);\n\n\t\t\tconst millisecondsDecimalDigits =\n\t\t\t\ttypeof options.millisecondsDecimalDigits === 'number' ?\n\t\t\t\t\toptions.millisecondsDecimalDigits :\n\t\t\t\t\t0;\n\n\t\t\tconst roundedMiliseconds = millisecondsAndBelow >= 1 ?\n\t\t\t\tMath.round(millisecondsAndBelow) :\n\t\t\t\tMath.ceil(millisecondsAndBelow);\n\n\t\t\tconst millisecondsString = millisecondsDecimalDigits ?\n\t\t\t\tmillisecondsAndBelow.toFixed(millisecondsDecimalDigits) :\n\t\t\t\troundedMiliseconds;\n\n\t\t\tadd(\n\t\t\t\tNumber.parseFloat(millisecondsString, 10),\n\t\t\t\t'millisecond',\n\t\t\t\t'ms',\n\t\t\t\tmillisecondsString\n\t\t\t);\n\t\t}\n\t} else {\n\t\tconst seconds = (milliseconds / 1000) % 60;\n\t\tconst secondsDecimalDigits =\n\t\t\ttypeof options.secondsDecimalDigits === 'number' ?\n\t\t\t\toptions.secondsDecimalDigits :\n\t\t\t\t1;\n\t\tconst secondsFixed = floorDecimals(seconds, secondsDecimalDigits);\n\t\tconst secondsString = options.keepDecimalsOnWholeSeconds ?\n\t\t\tsecondsFixed :\n\t\t\tsecondsFixed.replace(/\\.0+$/, '');\n\t\tadd(Number.parseFloat(secondsString, 10), 'second', 's', secondsString);\n\t}\n\n\tif (result.length === 0) {\n\t\treturn '0' + (options.verbose ? ' milliseconds' : 'ms');\n\t}\n\n\tif (options.compact) {\n\t\treturn result[0];\n\t}\n\n\tif (typeof options.unitCount === 'number') {\n\t\tconst separator = options.colonNotation ? '' : ' ';\n\t\treturn result.slice(0, Math.max(options.unitCount, 1)).join(separator);\n\t}\n\n\treturn options.colonNotation ? result.join('') : result.join(' ');\n};\n"]}